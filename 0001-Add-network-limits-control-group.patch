From 5e3c916f1a42f14248291e97fce27a490dcb37dd Mon Sep 17 00:00:00 2001
From: Dmitry Kurbatov <dk@dimcha.ru>
Date: Fri, 7 Aug 2015 19:18:23 +0300
Subject: [PATCH] Add network limits control group

---
 include/linux/cgroup_subsys.h   |   4 +
 include/linux/net_lim_cgroup.h  |  57 ++++
 init/Kconfig                    |   5 +
 kernel/Makefile                 |   1 +
 kernel/net_lim_cgroup.c         | 573 ++++++++++++++++++++++++++++++++++++++++
 net/ipv4/af_inet.c              |  27 +-
 net/ipv4/inet_connection_sock.c |  14 +
 7 files changed, 679 insertions(+), 2 deletions(-)
 create mode 100644 include/linux/net_lim_cgroup.h
 create mode 100644 kernel/net_lim_cgroup.c

diff --git a/include/linux/cgroup_subsys.h b/include/linux/cgroup_subsys.h
index e4a96fb..51e7c73 100644
--- a/include/linux/cgroup_subsys.h
+++ b/include/linux/cgroup_subsys.h
@@ -47,6 +47,10 @@ SUBSYS(net_prio)
 SUBSYS(hugetlb)
 #endif
 
+#if IS_ENABLED(CONFIG_CGROUP_NET_LIM)
+SUBSYS(net_lim)
+#endif
+
 /*
  * The following subsystems are not supported on the default hierarchy.
  */
diff --git a/include/linux/net_lim_cgroup.h b/include/linux/net_lim_cgroup.h
new file mode 100644
index 0000000..b83b219
--- /dev/null
+++ b/include/linux/net_lim_cgroup.h
@@ -0,0 +1,57 @@
+#ifndef _NET_LIM_CGROUP_H
+#define _NET_LIM_CGROUP_H
+
+#include <linux/kernel.h>
+#include <linux/threads.h>
+#include <linux/atomic.h>
+#include <linux/cgroup.h>
+#include <linux/slab.h>
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/rwlock_types.h>
+
+#define NET_LIM_ALLOW 0
+#define NET_LIM_DENY 1
+
+#define NET_LIM_PORTS_ALLOW 0
+#define NET_LIM_PORTS_DENY 1
+#define NET_LIM_ADDRS_ALLOW 2
+#define NET_LIM_ADDRS_DENY 3
+
+enum net_lim_behavior {
+	NET_LIM_DEFAULT_NONE,
+	NET_LIM_DEFAULT_ALLOW,
+	NET_LIM_DEFAULT_DENY,
+};
+
+struct net_lim_range_item {
+	u32 start, end;
+	struct list_head list;
+	struct rcu_head rcu;
+};
+
+struct net_lim_cgroup {
+	struct cgroup_subsys_state	css;
+
+	/* inet_bind() available ports range */
+	struct list_head port_ranges;
+	enum net_lim_behavior port_behavior;
+
+	/* inet_bind() available address range */
+	struct list_head addr_ranges;
+	enum net_lim_behavior addr_behavior;
+
+	/* ephemeral ports range */
+	int local_port_range[2];
+
+	/* default bind address used when try to bind on INADDR_ANY */
+	u32 default_address;
+};
+
+struct net_lim_cgroup *css_net_lim(struct cgroup_subsys_state *css);
+int net_lim_check_port(struct task_struct *tsk, unsigned int port);
+int net_lim_check_addr(struct task_struct *tsk, u32 addr);
+void net_lim_get_local_port_range(struct task_struct *tsk,
+	   						int *low, int *high);
+u32 net_lim_get_default_address(struct task_struct *tsk);
+#endif
diff --git a/init/Kconfig b/init/Kconfig
index af09b4f..f94a361 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -949,6 +949,11 @@ config CGROUP_DEBUG
 
 	  Say N if unsure.
 
+config CGROUP_NET_LIM
+	bool "Network limits cgroup subsystem"
+	help
+	  Provides custom network limits from cgroups
+
 config CGROUP_FREEZER
 	bool "Freezer cgroup subsystem"
 	help
diff --git a/kernel/Makefile b/kernel/Makefile
index 43c4c92..37a4e30 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_COMPAT) += compat.o
 obj-$(CONFIG_CGROUPS) += cgroup.o
 obj-$(CONFIG_CGROUP_FREEZER) += cgroup_freezer.o
 obj-$(CONFIG_CPUSETS) += cpuset.o
+obj-$(CONFIG_CGROUP_NET_LIM) += net_lim_cgroup.o
 obj-$(CONFIG_UTS_NS) += utsname.o
 obj-$(CONFIG_USER_NS) += user_namespace.o
 obj-$(CONFIG_PID_NS) += pid_namespace.o
diff --git a/kernel/net_lim_cgroup.c b/kernel/net_lim_cgroup.c
new file mode 100644
index 0000000..7624c4c
--- /dev/null
+++ b/kernel/net_lim_cgroup.c
@@ -0,0 +1,573 @@
+#include <linux/kernel.h>
+#include <linux/threads.h>
+#include <linux/atomic.h>
+#include <linux/cgroup.h>
+#include <linux/slab.h>
+#include <linux/net_lim_cgroup.h>
+
+#define NIPQUAD(addr) \
+    ((unsigned char *)&addr)[0], \
+    ((unsigned char *)&addr)[1], \
+    ((unsigned char *)&addr)[2], \
+    ((unsigned char *)&addr)[3]
+
+enum range_type {
+	PORT_RANGE,
+	ADDR_RANGE
+};
+
+static DEFINE_MUTEX(net_lim_cgroup_mutex);
+static DEFINE_RWLOCK(net_lim_croup_rwlock);
+
+struct net_lim_cgroup *css_net_lim(struct cgroup_subsys_state *css)
+{
+	return container_of(css, struct net_lim_cgroup, css);
+}
+
+static void net_lim_range_clean(struct list_head *list_ranges)
+{
+	struct net_lim_range_item *ex, *tmp;
+
+	list_for_each_entry_safe(ex, tmp, list_ranges, list) {
+		list_del_rcu(&ex->list);
+		kfree_rcu(ex, rcu);
+	}
+}
+
+static int net_lim_range_add(struct net_lim_range_item *range,
+                             struct list_head *list_ranges,
+                             enum range_type type)
+{
+	struct net_lim_range_item *excopy, *walk = NULL;
+	struct list_head *new_list = NULL;
+	int insert_before = 0;
+
+	lockdep_assert_held(&net_lim_cgroup_mutex);
+
+	excopy = kmemdup(range, sizeof(*range), GFP_KERNEL);
+	if (!excopy)
+		return -ENOMEM;
+
+	new_list = list_ranges;
+	list_for_each_entry(walk, list_ranges, list) {
+		new_list = &walk->list;
+		if ((( type = PORT_RANGE ) && (walk->start > excopy->start)) ||
+		                (( type = ADDR_RANGE ) &&
+		                 (htonl(walk->start) > htonl(excopy->start)))) {
+			insert_before = 1;
+			break;
+		}
+		if (walk->start == excopy->start) {
+			kfree(excopy);
+			return -EINVAL;
+		}
+	}
+
+	if (insert_before) {
+		list_add_tail_rcu(&excopy->list, new_list);
+	} else {
+		list_add_rcu(&excopy->list, new_list);
+	}
+	return 0;
+}
+
+static void set_port_allow_behavoir(struct net_lim_cgroup *net_lim)
+{
+	struct net_lim_range_item range;
+
+	range.start = 0;
+	range.end = 65535;
+	net_lim_range_clean(&net_lim->port_ranges);
+	net_lim_range_add(&range, &net_lim->port_ranges, PORT_RANGE);
+	net_lim->port_behavior = NET_LIM_DEFAULT_ALLOW;
+}
+
+static void set_addr_allow_behavoir(struct net_lim_cgroup *net_lim)
+{
+	struct net_lim_range_item range;
+
+	range.start = htonl(INADDR_ANY);
+	range.end = htonl(INADDR_ANY);
+	net_lim_range_clean(&net_lim->addr_ranges);
+	net_lim_range_add(&range, &net_lim->addr_ranges, ADDR_RANGE);
+	net_lim->addr_behavior = NET_LIM_DEFAULT_ALLOW;
+}
+
+/*
+ * Allocate new net_lim cgroup.
+ */
+static struct cgroup_subsys_state *
+net_lim_css_alloc(struct cgroup_subsys_state *parent)
+{
+	struct net_lim_cgroup *net_lim;
+
+	net_lim = kzalloc(sizeof(struct net_lim_cgroup), GFP_KERNEL);
+	if (!net_lim)
+		return ERR_PTR(-ENOMEM);
+
+	// TODO: copy parents settings (?)
+	/* initialize ports ranges. */
+	INIT_LIST_HEAD(&net_lim->port_ranges);
+	set_port_allow_behavoir(net_lim);
+
+	/* initialize addrs ranges. */
+	INIT_LIST_HEAD(&net_lim->addr_ranges);
+	set_addr_allow_behavoir(net_lim);
+
+	/* initialize local_port_range. */
+	/* TODO: copy init values from sysctl. */
+	net_lim->local_port_range[0] = 32768;
+	net_lim->local_port_range[1] = 61000;
+
+	/* initialize default bind address as INADDR_ANY */
+	net_lim->default_address = htonl(INADDR_ANY);
+
+	return &net_lim->css;
+}
+
+static void net_lim_ranges_clean(struct net_lim_cgroup *net_lim)
+{
+	net_lim_range_clean(&net_lim->port_ranges);
+	net_lim_range_clean(&net_lim->addr_ranges);
+}
+
+static void net_lim_css_free(struct cgroup_subsys_state *css)
+{
+	struct net_lim_cgroup *net_lim = css_net_lim(css);
+
+	net_lim_ranges_clean(net_lim);
+	kfree(net_lim);
+}
+
+/*
+ * Validate and extract port range string.
+ */
+int extract_port_range(char *str, u32 *start, u32 *end)
+{
+	char *tmp = str;
+
+	if (strlen(str) > 11)
+		return 1;
+
+	if (strchr(tmp, '-') == NULL) {
+		if (kstrtoint(str, 0, (int *)start))
+			return 1;
+		*end = *start;
+	} else {
+		tmp = strsep(&str, "-");
+
+		if ((*tmp == '\0') ||
+		                (str == NULL) ||
+		                (*str == '\0'))
+			return 1;
+
+		if (kstrtoint(tmp, 0, (int *)start))
+			return 1;
+		if (kstrtoint(str, 0, (int *)end))
+			return 1;
+	}
+
+	if ((*end < *start) ||
+	                (*start < 0) ||
+	                (*start > 65535) ||
+	                (*end < 0) ||
+	                (*end > 65535))
+		return 1;
+
+	return 0;
+}
+
+/*
+* Validate and extract address string.
+*/
+int extract_addr_range(char *str, u32 *start, u32 *end)
+{
+	if (strlen(str) > 15)
+		return 1;
+
+	if (!in4_pton(str, -1, (u8 *)start, -1, NULL)) {
+		return 1;
+	}
+
+	*end = 0;
+
+	return 0;
+}
+
+/*
+ * Called under net_lim_cgroup_mutex.
+ * Check existed range intersection with new one.
+ */
+static int net_lim_range_check_intersect(struct net_lim_range_item *range,
+                struct list_head *list_ranges)
+{
+	struct net_lim_range_item *walk;
+
+	lockdep_assert_held(&net_lim_cgroup_mutex);
+
+	list_for_each_entry(walk, list_ranges, list) {
+		if (((walk->start <= range->start)
+		                && (range->start <= walk->end))
+		                || ((walk->start <= range->end)
+		                    && (range->end <= walk->end)))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * Called under net_lim_cgroup_mutex.
+ * Remove range item from list.
+ */
+static int net_lim_range_rm(struct net_lim_range_item *range,
+                            struct list_head *list_ranges)
+{
+	struct net_lim_range_item *walk, *tmp;
+	int del_count = 0;
+
+	lockdep_assert_held(&net_lim_cgroup_mutex);
+
+	list_for_each_entry_safe(walk, tmp, list_ranges, list) {
+		if ((walk->start == range->start) &&
+		                (walk->end == range->end)) {
+			list_del_rcu(&walk->list);
+			kfree_rcu(walk, rcu);
+			del_count++;
+		}
+	}
+	return del_count;
+}
+
+/*
+ * Update network limits for `ports` and `addrs`.
+ */
+static int net_lim_cgroup_update_limits(struct net_lim_cgroup *net_lim,
+                                        int filetype, char *buffer)
+{
+	int ret, rc = 0;
+	struct net_lim_range_item ex;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (*buffer == '\0')
+		return -EINVAL;
+
+	memset(&ex, 0, sizeof(ex));
+
+	if (css_has_online_children(&net_lim->css))
+		return -EINVAL;
+
+	switch (filetype) {
+	case NET_LIM_PORTS_ALLOW:
+		if ((strlen(buffer) == 1) && (*buffer == 'a')) {
+			set_port_allow_behavoir(net_lim);
+			break;
+		} else {
+			/* Call extract_port_range() here for param check. */
+			if (extract_port_range(buffer, &ex.start, &ex.end))
+				return -EINVAL;
+			/* We already in ALLOW behavior - skip other actions. */
+			if (net_lim->port_behavior == NET_LIM_DEFAULT_ALLOW)
+				break;
+			if (net_lim_range_check_intersect(&ex,
+			                                  &net_lim->port_ranges))
+				return -EINVAL;
+			net_lim->port_behavior = NET_LIM_DEFAULT_NONE;
+			rc = net_lim_range_add(&ex, &net_lim->port_ranges,
+			                       PORT_RANGE);
+		}
+
+		break;
+
+	case NET_LIM_PORTS_DENY:
+		if ((strlen(buffer) == 1) && (*buffer == 'a')) {
+			net_lim_range_clean(&net_lim->port_ranges);
+			net_lim->port_behavior = NET_LIM_DEFAULT_DENY;
+		} else {
+			/* Call extract_port_range() here for param check. */
+			if (extract_port_range(buffer, &ex.start, &ex.end))
+				return -EINVAL;
+
+			/* We already in DENY behavior - skip other actions. */
+			if (net_lim->port_behavior == NET_LIM_DEFAULT_DENY)
+				break;
+
+			ret = net_lim_range_rm(&ex, &net_lim->port_ranges);
+			/* Reset behavior to NONE if changed something. */
+			if (ret)
+				net_lim->port_behavior = NET_LIM_DEFAULT_NONE;
+		}
+		break;
+
+	case NET_LIM_ADDRS_ALLOW:
+		if ((strlen(buffer) == 1) && (*buffer == 'a')) {
+			set_addr_allow_behavoir(net_lim);
+			break;
+		} else {
+			/* Call extract_addr_range() here for param check. */
+			if (extract_addr_range(buffer, &ex.start, &ex.end))
+				return -EINVAL;
+			/* We already in ALLOW behavior - skip other actions. */
+			if (net_lim->addr_behavior == NET_LIM_DEFAULT_ALLOW)
+				break;
+
+			net_lim->addr_behavior = NET_LIM_DEFAULT_NONE;
+			rc = net_lim_range_add(&ex, &net_lim->addr_ranges,
+			                       ADDR_RANGE);
+		}
+		break;
+
+	case NET_LIM_ADDRS_DENY:
+		if ((strlen(buffer) == 1) && (*buffer == 'a')) {
+			net_lim_range_clean(&net_lim->addr_ranges);
+			net_lim->addr_behavior = NET_LIM_DEFAULT_DENY;
+		} else {
+			/* Call extract_addr_range() here for param check. */
+			if (extract_addr_range(buffer, &ex.start, &ex.end))
+				return -EINVAL;
+			/* We already in DENY behavior - skip other actions. */
+			if (net_lim->addr_behavior == NET_LIM_DEFAULT_DENY)
+				break;
+			ret = net_lim_range_rm(&ex, &net_lim->addr_ranges);
+			/* Reset behavior to NONE if changed something. */
+			if (ret)
+				net_lim->addr_behavior = NET_LIM_DEFAULT_NONE;
+		}
+		break;
+	default:
+		rc = -EINVAL;
+	}
+	return rc;
+}
+
+static ssize_t net_lim_cgroup_limits_write(struct kernfs_open_file *of,
+                char *buf, size_t nbytes, loff_t off)
+{
+	int retval;
+
+	mutex_lock(&net_lim_cgroup_mutex);
+	retval = net_lim_cgroup_update_limits(css_net_lim(of_css(of)),
+	                                      of_cft(of)->private, strstrip(buf));
+	mutex_unlock(&net_lim_cgroup_mutex);
+	return retval ? : nbytes;
+}
+
+static int net_lim_cgroup_ports_seq_show(struct seq_file *seq, void *v)
+{
+	struct net_lim_range_item *range;
+	struct cgroup_subsys_state *css = seq_css(seq);
+	struct net_lim_cgroup *net_lim = css_net_lim(css);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(range, &net_lim->port_ranges, list) {
+		if (range->start == range->end) {
+			seq_printf(seq, "%d\n", range->start);
+		} else {
+			seq_printf(seq, "%d-%d\n", range->start, range->end);
+		}
+		// first = 0;
+	}
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int net_lim_cgroup_addrs_seq_show(struct seq_file *seq, void *v)
+{
+	struct net_lim_range_item *range;
+	struct cgroup_subsys_state *css = seq_css(seq);
+	struct net_lim_cgroup *net_lim = css_net_lim(css);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(range, &net_lim->addr_ranges, list) {
+		seq_printf(seq, "%d.%d.%d.%d\n", NIPQUAD(range->start));
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+static ssize_t net_lim_cgroup_local_port_range_write(struct kernfs_open_file *of,
+                                     char *buf, size_t nbytes, loff_t off)
+{
+	struct cgroup_subsys_state *css = of_css(of);
+	struct net_lim_cgroup *net_lim = css_net_lim(css);
+	int ports[2];
+	char *sbuf = strstrip(buf);
+
+	/* Check should we use sysctl values instead of cgroups. See doc for
+	details. */
+	if ((*sbuf == '-') && (*(sbuf+1) == '1') && (*(sbuf+2) == '\0')) {
+		ports[0] = ports[1] = -1;
+	} else {
+		if (extract_port_range(sbuf, &ports[0], &ports[1]))
+			return -EINVAL;
+	}
+
+	write_lock(&net_lim_croup_rwlock);
+	net_lim->local_port_range[0] = ports[0];
+	net_lim->local_port_range[1] = ports[1];
+	write_unlock(&net_lim_croup_rwlock);
+	return nbytes;
+}
+
+/*
+* Show current local_port_range value.
+*/
+static int net_lim_cgroup_local_port_range_seq_show(struct seq_file *seq,
+                                                    			void *v)
+{
+	struct cgroup_subsys_state *css = seq_css(seq);
+	struct net_lim_cgroup *net_lim = css_net_lim(css);
+
+	read_lock(&net_lim_croup_rwlock);
+	if (net_lim->local_port_range[0] == -1) {
+		seq_printf(seq, "-1\n");
+	} else {
+		seq_printf(seq, "%d-%d\n", net_lim->local_port_range[0],
+		           net_lim->local_port_range[1]);
+	}
+	read_unlock(&net_lim_croup_rwlock);
+
+	return 0;
+}
+/*
+ * Default address to substitute in case INADDR_ANY
+ */
+static ssize_t net_lim_cgroup_default_address_write(struct kernfs_open_file *of,
+                                     	char *buf, size_t nbytes, loff_t off)
+{
+	struct cgroup_subsys_state *css = of_css(of);
+	struct net_lim_cgroup *net_lim = css_net_lim(css);
+	char *sbuf = strstrip(buf);
+	u32 addr;
+
+	if (!in4_pton(sbuf, -1, (u8 *)&addr, -1, NULL)) {
+		return -EINVAL;
+	}
+
+	write_lock(&net_lim_croup_rwlock);
+	net_lim->default_address = addr;
+	write_unlock(&net_lim_croup_rwlock);
+	return nbytes;
+}
+
+/*
+* Show current default_address value.
+*/
+static int net_lim_cgroup_default_address_seq_show(struct seq_file *seq,
+                                                    			void *v)
+{
+	struct cgroup_subsys_state *css = seq_css(seq);
+	struct net_lim_cgroup *net_lim = css_net_lim(css);
+
+	read_lock(&net_lim_croup_rwlock);
+	seq_printf(seq, "%d.%d.%d.%d\n", NIPQUAD(net_lim->default_address));
+	read_unlock(&net_lim_croup_rwlock);
+
+	return 0;
+}
+
+static struct cftype net_lim_files[] = {
+	{
+		.name = "ipv4.ports.allow",
+		.write = net_lim_cgroup_limits_write,
+		.private = NET_LIM_PORTS_ALLOW,
+	},
+	{
+		.name = "ipv4.ports.deny",
+		.write = net_lim_cgroup_limits_write,
+		.private = NET_LIM_PORTS_DENY,
+	},
+	{
+		.name = "ipv4.ports.list",
+		.seq_show = net_lim_cgroup_ports_seq_show,
+	},
+	{
+		.name = "ipv4.addrs.allow",
+		.write = net_lim_cgroup_limits_write,
+		.private = NET_LIM_ADDRS_ALLOW,
+	},
+	{
+		.name = "ipv4.addrs.deny",
+		.write = net_lim_cgroup_limits_write,
+		.private = NET_LIM_ADDRS_DENY,
+	},
+	{
+		.name = "ipv4.addrs.list",
+		.seq_show = net_lim_cgroup_addrs_seq_show,
+	},
+	{
+		.name = "ipv4.ip_local_port_range",
+		.write = net_lim_cgroup_local_port_range_write,
+		.seq_show = net_lim_cgroup_local_port_range_seq_show,
+	},
+	{
+		.name = "ipv4.default_address",
+		.write = net_lim_cgroup_default_address_write,
+		.seq_show = net_lim_cgroup_default_address_seq_show,
+	},
+	{ }	/* terminate */
+};
+
+struct cgroup_subsys net_lim_cgrp_subsys = {
+	.css_alloc	= net_lim_css_alloc,
+	.css_free	= net_lim_css_free,
+	.legacy_cftypes	= net_lim_files,
+	.dfl_cftypes	= net_lim_files,
+};
+
+int net_lim_check_port(struct task_struct *tsk, unsigned int port)
+{
+	struct net_lim_cgroup *net_lim =
+			css_net_lim(tsk->cgroups->subsys[net_lim_cgrp_id]);
+	struct net_lim_range_item *walk;
+
+	rcu_read_lock();
+	list_for_each_entry(walk, &net_lim->port_ranges, list) {
+ 		if ((walk->start <= port) && (port <= walk->end))
+ 		        return 1;
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+int net_lim_check_addr(struct task_struct *tsk, u32 addr)
+{
+	struct net_lim_cgroup *net_lim =
+			css_net_lim(tsk->cgroups->subsys[net_lim_cgrp_id]);
+	struct net_lim_range_item *walk;
+
+	rcu_read_lock();
+	list_for_each_entry(walk, &net_lim->addr_ranges, list) {
+ 		if ((walk->start == htonl(INADDR_ANY)) || (walk->start == addr))
+ 		        return 1;
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+void net_lim_get_local_port_range(struct task_struct *tsk,
+	   						int *low, int *high)
+{
+	struct net_lim_cgroup *net_lim =
+			css_net_lim(tsk->cgroups->subsys[net_lim_cgrp_id]);
+
+	read_lock(&net_lim_croup_rwlock);
+	*low = net_lim->local_port_range[0];
+	*high = net_lim->local_port_range[1];
+	read_unlock(&net_lim_croup_rwlock);
+}
+
+u32 net_lim_get_default_address(struct task_struct *tsk)
+{
+	struct net_lim_cgroup *net_lim =
+			css_net_lim(tsk->cgroups->subsys[net_lim_cgrp_id]);
+	u32 addr;
+
+	rcu_read_lock();
+	addr = net_lim->default_address;
+	rcu_read_unlock();
+	return addr;
+}
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 9532ee8..38804db 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -119,7 +119,12 @@
 #include <linux/mroute.h>
 #endif
 
-
+#ifdef CONFIG_CGROUP_RLIM
+#include <linux/cgroup_rlim.h>
+#endif
+#ifdef CONFIG_CGROUP_NET_LIM
+#include <linux/net_lim_cgroup.h>
+#endif
 /* The inetsw table contains everything that inet_create needs to
  * build a new socket.
  */
@@ -427,7 +432,12 @@ int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 	unsigned short snum;
 	int chk_addr_ret;
 	int err;
+#ifdef CONFIG_CGROUP_NET_LIM
+	u32 def_addr = net_lim_get_default_address(get_current());
 
+	if (addr->sin_addr.s_addr == htonl(INADDR_ANY))
+		addr->sin_addr.s_addr = def_addr;
+#endif
 	/* If the socket has its own bind function then use it. (RAW) */
 	if (sk->sk_prot->bind) {
 		err = sk->sk_prot->bind(sk, uaddr, addr_len);
@@ -467,6 +477,20 @@ int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 
 	snum = ntohs(addr->sin_port);
 	err = -EACCES;
+#ifdef CONFIG_CGROUP_NET_LIM
+	// printk("XXX: bind()\n");
+	// if (addr->sin_addr.s_addr != htonl(INADDR_ANY) &&
+	if (!net_lim_check_addr(get_current(), addr->sin_addr.s_addr)) {
+	    	// printk("XXX: catch forbidden address: %pI4\n",
+	    	//        					&addr->sin_addr.s_addr);
+		goto out;
+	}
+
+	if (!net_lim_check_port(get_current(), snum)) {
+		// printk("XXX: catch forbidden port: %d\n", snum);
+		goto out;
+	}
+#endif
 	if (snum && snum < PROT_SOCK &&
 	    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))
 		goto out;
@@ -1834,4 +1858,3 @@ static int __init ipv4_proc_init(void)
 #endif /* CONFIG_PROC_FS */
 
 MODULE_ALIAS_NETPROTO(PF_INET);
-
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index 60021d0..6ebebcb 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -6,6 +6,7 @@
  *		Support for INET connection oriented protocols.
  *
  * Authors:	See the TCP sources
+ * TODO: ret
  *
  *		This program is free software; you can redistribute it and/or
  *		modify it under the terms of the GNU General Public License
@@ -24,6 +25,9 @@
 #include <net/tcp_states.h>
 #include <net/xfrm.h>
 #include <net/tcp.h>
+#ifdef CONFIG_CGROUP_NET_LIM
+#include <linux/net_lim_cgroup.h>
+#endif
 
 #ifdef INET_CSK_DEBUG
 const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
@@ -33,6 +37,10 @@ EXPORT_SYMBOL(inet_csk_timer_bug_msg);
 void inet_get_local_port_range(struct net *net, int *low, int *high)
 {
 	unsigned int seq;
+#ifdef CONFIG_CGROUP_NET_LIM
+	net_lim_get_local_port_range(get_current(), low, high);
+	if (*low == -1) {
+#endif
 
 	do {
 		seq = read_seqbegin(&net->ipv4.ip_local_ports.lock);
@@ -40,6 +48,12 @@ void inet_get_local_port_range(struct net *net, int *low, int *high)
 		*low = net->ipv4.ip_local_ports.range[0];
 		*high = net->ipv4.ip_local_ports.range[1];
 	} while (read_seqretry(&net->ipv4.ip_local_ports.lock, seq));
+#ifdef CONFIG_CGROUP_NET_LIM
+	}
+	// printk("XXX: inet_get_local_port_range(): pid: %d low: %d high: %d\n",
+	// 				get_current()->pid, *low, *high);
+#endif
+
 }
 EXPORT_SYMBOL(inet_get_local_port_range);
 
-- 
2.1.0

